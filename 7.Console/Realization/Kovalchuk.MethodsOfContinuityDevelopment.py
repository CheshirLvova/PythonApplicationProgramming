#підключення модулів для роботи з файлами та сценаріями
import os
import subprocess
import shutil
import time
from random import randint
##Задача 1. Запуск програм з сценаріїв в режимі "Запуск файла зі зв'язаною аплікацією".
##В свою поточну папку спочатку копіювати вручну будь-який невеликий файл
##документа Word і так само невеликий файл малюнка формата jpeg або bmp. В сценарії
##визначити імена цих файлів за допомогою функцій, розглянутих в темі "Робота з файлами і
##каталогами". Якщо файлів такого типу багато – вибрати лише один з файлів. Запустити на
##виконання. Переконатись, що запуск виконаний – має відкритись вікно відповідної
##програми. Виконати одну-дві прості операції редагування відкритих документів і закрити
##запущені програми.

def task1():
    #копіюю потрібні файли у поточну папку
    shutil.copyfile(r'D:/Studying/PythonApplicationProgramming/7Console/FilesForCopy/1.jpeg', r'1.jpeg')
    print('Файл 1.jpeg скопійовано з папки FilesForCopy в поточну папку!')
    shutil.copyfile(r'D:/Studying/PythonApplicationProgramming/7Console/FilesForCopy/7.docx', r'7.docx')
    print('Файл 7.docx скопійовано з папки FilesForCopy в поточну папку!')
    #в сценарії визначаю нове ім'я для одного з файлів
    os.rename('7.docx', 'Renamed.docx')
    print('Визначено нове ім\'я для файлу 7.docx -> Renamed.docx')
    #виконую запуск скопійованих програм та переконуюсь, що відкриваються вікна відповідних програм
    img = os.startfile('1.jpeg')
    print('Відкрито зображення 1.jpeg')
    file = os.startfile('Renamed.docx')
    print('Відкрито файл Renamed.docx')
    #прості операції редагування відкритих документів та закриття запущених програм виконала вручну
    time.sleep(2)
    pass

##Задача 2. Запуск програм з сценаріїв в режимі "Передача керування іншій програмі".
##[ Спочатку можна виконати ознайомчі вправи з прикладною програмою калькулятора
##комплексних чисел PrjCompl.exe. Ця програма передана до папки "Навчальні матеріали". ]
##В поточну папку спочатку копіювати вручну декілька файлів однакового типу. В
##сценарії визначити імена таких файлів функціями роботи з файлами. Запустити на перегляд
##всі файли зразу. Запуск можна виконати: а) багатократно, за кожним запуском передавати
##один файл; б) однократно, передавши список файлів як список параметрів.
##Увага! 1) Якщо якийсь крок запуску оформлений неправильно, то може бути загальний
##збій як запущеної програми, так і самого сценарію. Треба дуже точно виконати кроки
##підготовки до запуску. 2) Не всім системним програмам "подобається" такий швидкий спосіб
##запуску. Можливі відмови виконання.

def task2():
    #копіюю потрібні файли у поточну папку
    shutil.copyfile(r'D:/Studying/PythonApplicationProgramming/7Console/FilesForCopy/2.jpg', r'2.jpg')
    print('Файл 2.jpg скопійовано з папки FilesForCopy в поточну папку!')
    shutil.copyfile(r'D:/Studying/PythonApplicationProgramming/7Console/FilesForCopy/3.jpg', r'3.jpg')
    print('Файл 3.jpg скопійовано з папки FilesForCopy в поточну папку!')
    shutil.copyfile(r'D:/Studying/PythonApplicationProgramming/7Console/FilesForCopy/4.jpg', r'4.jpg')
    print('Файл 4.jpg скопійовано з папки FilesForCopy в поточну папку!')
    shutil.copyfile(r'D:/Studying/PythonApplicationProgramming/7Console/FilesForCopy/5.jpg', r'5.jpg')
    print('Файл 5.jpg скопійовано з папки FilesForCopy в поточну папку!')
    shutil.copyfile(r'D:/Studying/PythonApplicationProgramming/7Console/FilesForCopy/6.jpg', r'6.jpg')
    print('Файл 6.jpg скопійовано з папки FilesForCopy в поточну папку!')
    #багатократно, за кожним запуском запускаю на перегляд один файл
    spysok = ['2', '3', '4', '5', '6']
    for i in range(len(spysok)):
        image = spysok[i] + '.jpg'
        img = os.startfile(image)
        print('Відкрито зображення ', image)
    pass

##Задача 3. Скласти власний сценарій з виконанням дочірнього процесу, в якому працює
##власна програма довільного змісту, в режимі "Очікування закінчення дочірнього процесу".
##Зразок такого сценарію є в файлі "Методи організації сценаріїв.pdf".
##Для демонстрації обрати просту програму, написану на С++ і скомпільовану в exeфайл, яка
##б не вимагала спеціальних додаткових ресурсів на час свого виконання.
##Потрібно так комбінувати основний і дочірній процес, щоб можна було побачити
##спільну роботу основного сценарію і дочірнього процесу – для демонстрації. В прикладі,
##записаному в зразку, демонстрація є за рахунок почергового редагування одного файла, з
##друкуванням результатів на спільній консолі.
##Визначити самостійно тему (задачу) виконання основного і дочірнього процесу. Теми
##не зобов'язані бути однаковими.

def task3():
    print("main process - started") # початок основного процесу
    # запускаємо паралельний дочірній процес
    dirname = os.path.abspath('.') # шлях від кореня до поточної папки
    filename = os.path.join(dirname, 'sum.exe')
    parprog = subprocess.Popen(["python", filename])
    # після запуску основний процес продовжує виконання
    time.sleep(2) # затримати виконання на 2 секунди
    print("main process - continue") # продовження основного процесу
    # . . . . .
    # перевірити стан дочірнього процесу
    print( "subprocess finished ? ", parprog.poll() )
    print("main process - finished")
    time.sleep(1) # затримати виконання на 1 секундy
    print("subprocess finished")
    pass

def main():
    print("Опісля вибору завдання для виконання програма покаже результат задачі та буде потрібно перезапустити програму для повторної операції!\n")
    answer = input("Оберіть номер завдання для виконання(1-3): ")
    if answer == "1":
        print("Виконання першого завдання: ")
        return task1()    
    elif answer == "2":
        print("Виконання другого завдання: ")
        return task2()
    elif answer == "3":
        print("Виконання третього завдання: ")
        return task3()
    else:
        return main()
    
main()

